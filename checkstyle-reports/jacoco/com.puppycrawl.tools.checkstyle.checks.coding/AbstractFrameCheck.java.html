<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractFrameCheck.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checkstyle</a> &gt; <a href="index.source.html" class="el_package">com.puppycrawl.tools.checkstyle.checks.coding</a> &gt; <span class="el_source">AbstractFrameCheck.java</span></div><h1>AbstractFrameCheck.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code for adherence to a set of rules.
// Copyright (C) 2001-2020 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

package com.puppycrawl.tools.checkstyle.checks.coding;

import java.util.*;

import com.puppycrawl.tools.checkstyle.FileStatefulCheck;
import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;
import com.puppycrawl.tools.checkstyle.utils.CheckUtil;
import com.puppycrawl.tools.checkstyle.utils.ScopeUtil;

/**
 * -@cs[ClassDataAbstractionCoupling]
 * Abstract class for checks which requires to work with and identify many frames.
 */
@FileStatefulCheck
<span class="fc" id="L36">public abstract class AbstractFrameCheck extends AbstractCheck {</span>

    /**
     * Frame for the currently processed AST.
     */
<span class="fc" id="L41">    protected final Deque&lt;AbstractFrame&gt; current = new ArrayDeque&lt;&gt;();</span>

    /**
     * Tree of all the parsed frames.
     */
    protected Map&lt;DetailAST, AbstractFrame&gt; frames;

    /**
     * Parses the next AST for declarations.
     *
     * @param frameStack stack containing the FrameTree being built.
     * @param ast        AST to parse.
     */
    abstract void collectDeclarations(Deque&lt;AbstractFrame&gt; frameStack, DetailAST ast);

    /**
     * Ends parsing of the AST for declarations.
     *
     * @param frameStack Stack containing the FrameTree being built.
     * @param ast        AST that was parsed.
     */
    abstract void endCollectingDeclarations(Queue&lt;AbstractFrame&gt; frameStack, DetailAST ast);

    @Override
    public void beginTree(DetailAST rootAST) {
<span class="fc" id="L66">        frames = new HashMap&lt;&gt;();</span>
<span class="fc" id="L67">        current.clear();</span>

<span class="fc" id="L69">        final Deque&lt;AbstractFrame&gt; frameStack = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L70">        DetailAST curNode = rootAST;</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">        while (curNode != null) {</span>
<span class="fc" id="L72">            collectDeclarations(frameStack, curNode);</span>
<span class="fc" id="L73">            DetailAST toVisit = curNode.getFirstChild();</span>
<span class="fc bfc" id="L74" title="All 4 branches covered.">            while (curNode != null &amp;&amp; toVisit == null) {</span>
<span class="fc" id="L75">                endCollectingDeclarations(frameStack, curNode);</span>
<span class="fc" id="L76">                toVisit = curNode.getNextSibling();</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">                if (toVisit == null) {</span>
<span class="fc" id="L78">                    curNode = curNode.getParent();</span>
                }
            }
<span class="fc" id="L81">            curNode = toVisit;</span>
<span class="fc" id="L82">        }</span>
<span class="fc" id="L83">    }</span>


    /**
     * Collects variable declarations.
     *
     * @param ast   variable token.
     * @param frame current frame.
     */
    void collectVariableDeclarations(DetailAST ast, AbstractFrame frame) {
<span class="fc" id="L93">        final DetailAST ident = ast.findFirstToken(TokenTypes.IDENT);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        if (frame.getType() == FrameType.CLASS_FRAME) {</span>
<span class="fc" id="L95">            final DetailAST mods =</span>
<span class="fc" id="L96">                    ast.findFirstToken(TokenTypes.MODIFIERS);</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">            if (ScopeUtil.isInInterfaceBlock(ast)</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">                    || mods.findFirstToken(TokenTypes.LITERAL_STATIC) != null) {</span>
<span class="fc" id="L99">                ((ClassFrame) frame).addStaticMember(ident);</span>
            } else {
<span class="fc" id="L101">                ((ClassFrame) frame).addInstanceMember(ident);</span>
            }
<span class="fc" id="L103">        } else {</span>
<span class="fc" id="L104">            frame.addIdent(ident);</span>
        }
<span class="fc" id="L106">    }</span>

    /**
     * Gets the name of the nearest parent ClassFrame.
     *
     * @return the name of the nearest parent ClassFrame.
     */
    String getNearestClassFrameName() {
<span class="fc" id="L114">        return getNearestClassFrame().getFrameName();</span>
    }

    /**
     * Gets the name of the nearest parent ClassFrame.
     *
     * @return the name of the nearest parent ClassFrame.
     */
    AbstractFrame getNearestClassFrame() {
<span class="fc" id="L123">        AbstractFrame frame = current.peek();</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        while (frame.getType() != FrameType.CLASS_FRAME) {</span>
<span class="fc" id="L125">            frame = frame.getParent();</span>
        }
<span class="fc" id="L127">        return frame;</span>
    }

    /**
     * Find the class frame containing declaration.
     *
     * @param name          IDENT ast of the declaration to find.
     * @param lookForMethod whether we are looking for a method name.
     * @return AbstractFrame containing declaration or null.
     */
    AbstractFrame findClassFrame(DetailAST name, boolean lookForMethod) {
<span class="fc" id="L138">        AbstractFrame frame = current.peek();</span>

        while (true) {
<span class="fc" id="L141">            frame = findFrame(frame, name, lookForMethod);</span>

<span class="fc bfc" id="L143" title="All 4 branches covered.">            if (frame == null || frame instanceof ClassFrame) {</span>
<span class="fc" id="L144">                break;</span>
            }

<span class="fc" id="L147">            frame = frame.getParent();</span>
        }

<span class="fc" id="L150">        return frame;</span>
    }

    /**
     * Find frame containing declaration.
     *
     * @param name          IDENT ast of the declaration to find.
     * @param lookForMethod whether we are looking for a method name.
     * @return AbstractFrame containing declaration or null.
     */
    AbstractFrame findFrame(DetailAST name, boolean lookForMethod) {
<span class="fc" id="L161">        return findFrame(current.peek(), name, lookForMethod);</span>
    }

    /**
     * Find frame containing declaration.
     *
     * @param frame         The parent frame to searching in.
     * @param name          IDENT ast of the declaration to find.
     * @param lookForMethod whether we are looking for a method name.
     * @return AbstractFrame containing declaration or null.
     */
    private static AbstractFrame findFrame(AbstractFrame frame, DetailAST name,
                                           boolean lookForMethod) {
<span class="fc" id="L174">        return frame.getIfContains(name, lookForMethod);</span>
    }

    /**
     * Whether the AST is a definition of an anonymous class.
     *
     * @param ast the AST to process.
     * @return true if the AST is a definition of an anonymous class.
     */
    static boolean isAnonymousClassDef(DetailAST ast) {
<span class="fc" id="L184">        final DetailAST lastChild = ast.getLastChild();</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        return lastChild != null</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">                &amp;&amp; lastChild.getType() == TokenTypes.OBJBLOCK;</span>
    }

    /**
     * Checks if 2 AST are similar by their type and text.
     *
     * @param left  The first AST to check.
     * @param right The second AST to check.
     * @return {@code true} if they are similar.
     */
    private static boolean isAstSimilar(DetailAST left, DetailAST right) {
<span class="pc bpc" id="L197" title="1 of 4 branches missed.">        return left.getType() == right.getType() &amp;&amp; left.getText().equals(right.getText());</span>
    }

    /**
     * An AbstractFrame type.
     */
<span class="fc" id="L203">    protected enum FrameType {</span>

        /**
         * Class frame type.
         */
<span class="fc" id="L208">        CLASS_FRAME,</span>
        /**
         * Constructor frame type.
         */
<span class="fc" id="L212">        CTOR_FRAME,</span>
        /**
         * Method frame type.
         */
<span class="fc" id="L216">        METHOD_FRAME,</span>
        /**
         * Block frame type.
         */
<span class="fc" id="L220">        BLOCK_FRAME,</span>
        /**
         * Catch frame type.
         */
<span class="fc" id="L224">        CATCH_FRAME,</span>
        /**
         * Lambda frame type.
         */
<span class="fc" id="L228">        FOR_FRAME,</span>

    }

    /**
     * A declaration frame.
     */
    protected abstract static class AbstractFrame {

        /**
         * Set of name of variables declared in this frame.
         */
        private final Set&lt;DetailAST&gt; varIdents;

        /**
         * Parent frame.
         */
        private final AbstractFrame parent;

        /**
         * Name identifier token.
         */
        private final DetailAST frameNameIdent;

        /**
         * Constructor -- invocable only via super() from subclasses.
         *
         * @param parent parent frame.
         * @param ident  frame name ident.
         */
<span class="fc" id="L258">        protected AbstractFrame(AbstractFrame parent, DetailAST ident) {</span>
<span class="fc" id="L259">            this.parent = parent;</span>
<span class="fc" id="L260">            frameNameIdent = ident;</span>
<span class="fc" id="L261">            varIdents = new HashSet&lt;&gt;();</span>
<span class="fc" id="L262">        }</span>

        /**
         * Get the type of the frame.
         *
         * @return a FrameType.
         */
        protected abstract FrameType getType();

        /**
         * Add a name to the frame.
         *
         * @param identToAdd the name we're adding.
         */
        void addIdent(DetailAST identToAdd) {
<span class="fc" id="L277">            varIdents.add(identToAdd);</span>
<span class="fc" id="L278">        }</span>

        protected AbstractFrame getParent() {
<span class="fc" id="L281">            return parent;</span>
        }

        protected String getFrameName() {
<span class="fc" id="L285">            return frameNameIdent.getText();</span>
        }

        DetailAST getFrameNameIdent() {
<span class="fc" id="L289">            return frameNameIdent;</span>
        }

        /**
         * Check whether the frame contains a field or a variable with the given name.
         *
         * @param nameToFind the IDENT ast of the name we're looking for.
         * @return whether it was found.
         */
        protected boolean containsFieldOrVariable(DetailAST nameToFind) {
<span class="fc" id="L299">            return containsFieldOrVariableDef(varIdents, nameToFind);</span>
        }

        /**
         * Check whether the frame contains a given name.
         *
         * @param nameToFind    IDENT ast of the name we're looking for.
         * @param lookForMethod whether we are looking for a method name.
         * @return whether it was found.
         */
        protected AbstractFrame getIfContains(DetailAST nameToFind, boolean lookForMethod) {
            final AbstractFrame frame;

<span class="fc bfc" id="L312" title="All 2 branches covered.">            if (!lookForMethod</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">                    &amp;&amp; containsFieldOrVariable(nameToFind)) {</span>
<span class="fc" id="L314">                frame = this;</span>
            } else {
<span class="fc" id="L316">                frame = parent.getIfContains(nameToFind, lookForMethod);</span>
            }
<span class="fc" id="L318">            return frame;</span>
        }

        /**
         * Whether the set contains a declaration with the text of the specified
         * IDENT ast and it is declared in a proper position.
         *
         * @param set   the set of declarations.
         * @param ident the specified IDENT ast.
         * @return true if the set contains a declaration with the text of the specified
         * IDENT ast and it is declared in a proper position.
         */
        protected boolean containsFieldOrVariableDef(Set&lt;DetailAST&gt; set, DetailAST ident) {
<span class="fc" id="L331">            boolean result = false;</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">            for (DetailAST ast : set) {</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">                if (isProperDefinition(ident, ast)) {</span>
<span class="fc" id="L334">                    result = true;</span>
<span class="fc" id="L335">                    break;</span>
                }
<span class="fc" id="L337">            }</span>
<span class="fc" id="L338">            return result;</span>
        }

        /**
         * Whether the definition is correspondent to the IDENT.
         *
         * @param ident the IDENT ast to check.
         * @param ast   the IDENT ast of the definition to check.
         * @return true if ast is correspondent to ident.
         */
        protected boolean isProperDefinition(DetailAST ident, DetailAST ast) {
<span class="fc" id="L349">            final String nameToFind = ident.getText();</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">            return nameToFind.equals(ast.getText())</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">                    &amp;&amp; CheckUtil.isBeforeInSource(ast, ident);</span>
        }
    }

    /**
     * A frame initiated at method definition; holds a method definition token.
     */
    protected static class MethodFrame extends AbstractFrame {

        /**
         * Creates method frame.
         *
         * @param parent parent frame.
         * @param ident  method name identifier token.
         */
        protected MethodFrame(AbstractFrame parent, DetailAST ident) {
<span class="fc" id="L367">            super(parent, ident);</span>
<span class="fc" id="L368">        }</span>

        @Override
        protected FrameType getType() {
<span class="fc" id="L372">            return FrameType.METHOD_FRAME;</span>
        }

    }

    /**
     * A frame initiated at constructor definition.
     */
    protected static class ConstructorFrame extends AbstractFrame {

        /**
         * Creates a constructor frame.
         *
         * @param parent parent frame.
         * @param ident  frame name ident.
         */
        protected ConstructorFrame(AbstractFrame parent, DetailAST ident) {
<span class="fc" id="L389">            super(parent, ident);</span>
<span class="fc" id="L390">        }</span>

        @Override
        protected FrameType getType() {
<span class="fc" id="L394">            return FrameType.CTOR_FRAME;</span>
        }

    }

    /**
     * A frame initiated at class, enum or interface definition; holds instance variable names.
     */
    protected static class ClassFrame extends AbstractFrame {

        /**
         * Set of idents of instance members declared in this frame.
         */
        private final Set&lt;DetailAST&gt; instanceMembers;
        /**
         * Set of idents of instance methods declared in this frame.
         */
        private final Set&lt;DetailAST&gt; instanceMethods;
        /**
         * Set of idents of variables declared in this frame.
         */
        private final Set&lt;DetailAST&gt; staticMembers;
        /**
         * Set of idents of static methods declared in this frame.
         */
        private final Set&lt;DetailAST&gt; staticMethods;

        /**
         * Creates new instance of ClassFrame.
         *
         * @param parent parent frame.
         * @param ident  frame name ident.
         */
        /* package */ ClassFrame(AbstractFrame parent, DetailAST ident) {
<span class="fc" id="L428">            super(parent, ident);</span>
<span class="fc" id="L429">            instanceMembers = new HashSet&lt;&gt;();</span>
<span class="fc" id="L430">            instanceMethods = new HashSet&lt;&gt;();</span>
<span class="fc" id="L431">            staticMembers = new HashSet&lt;&gt;();</span>
<span class="fc" id="L432">            staticMethods = new HashSet&lt;&gt;();</span>
<span class="fc" id="L433">        }</span>

        @Override
        protected FrameType getType() {
<span class="fc" id="L437">            return FrameType.CLASS_FRAME;</span>
        }

        /**
         * Adds static member's ident.
         *
         * @param ident an ident of static member of the class.
         */
        public void addStaticMember(final DetailAST ident) {
<span class="fc" id="L446">            staticMembers.add(ident);</span>
<span class="fc" id="L447">        }</span>

        /**
         * Adds static method's name.
         *
         * @param ident an ident of static method of the class.
         */
        public void addStaticMethod(final DetailAST ident) {
<span class="fc" id="L455">            staticMethods.add(ident);</span>
<span class="fc" id="L456">        }</span>

        /**
         * Adds instance member's ident.
         *
         * @param ident an ident of instance member of the class.
         */
        public void addInstanceMember(final DetailAST ident) {
<span class="fc" id="L464">            instanceMembers.add(ident);</span>
<span class="fc" id="L465">        }</span>

        /**
         * Adds instance method's name.
         *
         * @param ident an ident of instance method of the class.
         */
        public void addInstanceMethod(final DetailAST ident) {
<span class="fc" id="L473">            instanceMethods.add(ident);</span>
<span class="fc" id="L474">        }</span>

        /**
         * Checks if a given name is a known instance member of the class.
         *
         * @param ident the IDENT ast of the name to check.
         * @return true is the given name is a name of a known
         * instance member of the class.
         */
        public boolean hasInstanceMember(final DetailAST ident) {
<span class="fc" id="L484">            return containsFieldOrVariableDef(instanceMembers, ident);</span>
        }

        /**
         * Checks if a given name is a known instance method of the class.
         *
         * @param ident the IDENT ast of the method call to check.
         * @return true if the given ast is correspondent to a known
         * instance method of the class.
         */
        public boolean hasInstanceMethod(final DetailAST ident) {
<span class="fc" id="L495">            return containsMethodDef(instanceMethods, ident);</span>
        }

        /**
         * Checks if a given name is a known static method of the class.
         *
         * @param ident the IDENT ast of the method call to check.
         * @return true is the given ast is correspondent to a known
         * instance method of the class.
         */
        public boolean hasStaticMethod(final DetailAST ident) {
<span class="fc" id="L506">            return containsMethodDef(staticMethods, ident);</span>
        }

        /**
         * Checks whether given instance member has final modifier.
         *
         * @param instanceMember an instance member of a class.
         * @return true if given instance member has final modifier.
         */
        public boolean hasFinalField(final DetailAST instanceMember) {
<span class="fc" id="L516">            boolean result = false;</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">            for (DetailAST member : instanceMembers) {</span>
<span class="fc" id="L518">                final DetailAST mods = member.getParent().findFirstToken(TokenTypes.MODIFIERS);</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">                final boolean finalMod = mods.findFirstToken(TokenTypes.FINAL) != null;</span>
<span class="fc bfc" id="L520" title="All 4 branches covered.">                if (finalMod &amp;&amp; isAstSimilar(member, instanceMember)) {</span>
<span class="fc" id="L521">                    result = true;</span>
<span class="fc" id="L522">                    break;</span>
                }
<span class="fc" id="L524">            }</span>
<span class="fc" id="L525">            return result;</span>
        }

        @Override
        protected boolean containsFieldOrVariable(DetailAST nameToFind) {
<span class="fc bfc" id="L530" title="All 2 branches covered.">            return containsFieldOrVariableDef(instanceMembers, nameToFind)</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">                    || containsFieldOrVariableDef(staticMembers, nameToFind);</span>
        }

        @Override
        protected boolean isProperDefinition(DetailAST ident, DetailAST ast) {
<span class="fc" id="L536">            final String nameToFind = ident.getText();</span>
<span class="fc" id="L537">            return nameToFind.equals(ast.getText());</span>
        }

        @Override
        protected AbstractFrame getIfContains(DetailAST nameToFind, boolean lookForMethod) {
<span class="fc" id="L542">            AbstractFrame frame = null;</span>

<span class="fc bfc" id="L544" title="All 4 branches covered.">            if (lookForMethod &amp;&amp; containsMethod(nameToFind)</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">                    || containsFieldOrVariable(nameToFind)) {</span>
<span class="fc" id="L546">                frame = this;</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">            } else if (getParent() != null) {</span>
<span class="fc" id="L548">                frame = getParent().getIfContains(nameToFind, lookForMethod);</span>
            }
<span class="fc" id="L550">            return frame;</span>
        }

        /**
         * Check whether the frame contains a given method.
         *
         * @param methodToFind the AST of the method to find.
         * @return true, if a method with the same name and number of parameters is found.
         */
        private boolean containsMethod(DetailAST methodToFind) {
<span class="fc bfc" id="L560" title="All 2 branches covered.">            return containsMethodDef(instanceMethods, methodToFind)</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">                    || containsMethodDef(staticMethods, methodToFind);</span>
        }

        /**
         * Whether the set contains a method definition with the
         * same name and number of parameters.
         *
         * @param set   the set of definitions.
         * @param ident the specified method call IDENT ast.
         * @return true if the set contains a definition with the
         * same name and number of parameters.
         */
        private static boolean containsMethodDef(Set&lt;DetailAST&gt; set, DetailAST ident) {
<span class="fc" id="L574">            boolean result = false;</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">            for (DetailAST ast : set) {</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">                if (isSimilarSignature(ident, ast)) {</span>
<span class="fc" id="L577">                    result = true;</span>
<span class="fc" id="L578">                    break;</span>
                }
<span class="fc" id="L580">            }</span>
<span class="fc" id="L581">            return result;</span>
        }

        /**
         * Whether the method definition has the same name and number of parameters.
         *
         * @param ident the specified method call IDENT ast.
         * @param ast   the ast of a method definition to compare with.
         * @return true if a method definition has the same name and number of parameters
         * as the method call.
         */
        private static boolean isSimilarSignature(DetailAST ident, DetailAST ast) {
<span class="fc" id="L593">            boolean result = false;</span>
<span class="fc" id="L594">            final DetailAST elistToken = ident.getParent().findFirstToken(TokenTypes.ELIST);</span>
<span class="fc bfc" id="L595" title="All 4 branches covered.">            if (elistToken != null &amp;&amp; ident.getText().equals(ast.getText())) {</span>
<span class="fc" id="L596">                final int paramsNumber =</span>
<span class="fc" id="L597">                        ast.getParent().findFirstToken(TokenTypes.PARAMETERS).getChildCount();</span>
<span class="fc" id="L598">                final int argsNumber = elistToken.getChildCount();</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">                result = paramsNumber == argsNumber;</span>
            }
<span class="fc" id="L601">            return result;</span>
        }

    }

    /**
     * An anonymous class frame; holds instance variable names.
     */
    protected static class AnonymousClassFrame extends ClassFrame {

        /**
         * The name of the frame.
         */
        private final String frameName;

        /**
         * Creates anonymous class frame.
         *
         * @param parent    parent frame.
         * @param frameName name of the frame.
         */
        protected AnonymousClassFrame(AbstractFrame parent, String frameName) {
<span class="fc" id="L623">            super(parent, null);</span>
<span class="fc" id="L624">            this.frameName = frameName;</span>
<span class="fc" id="L625">        }</span>

        @Override
        protected String getFrameName() {
<span class="fc" id="L629">            return frameName;</span>
        }

    }

    /**
     * A frame initiated on entering a statement list; holds local variable names.
     */
    protected static class BlockFrame extends AbstractFrame {

        /**
         * Creates block frame.
         *
         * @param parent parent frame.
         * @param ident  ident frame name ident.
         */
        protected BlockFrame(AbstractFrame parent, DetailAST ident) {
<span class="fc" id="L646">            super(parent, ident);</span>
<span class="fc" id="L647">        }</span>

        @Override
        protected FrameType getType() {
<span class="fc" id="L651">            return FrameType.BLOCK_FRAME;</span>
        }

    }

    /**
     * A frame initiated on entering a catch block; holds local catch variable names.
     */
    protected static class CatchFrame extends AbstractFrame {

        /**
         * Creates catch frame.
         *
         * @param parent parent frame.
         * @param ident  ident frame name ident.
         */
        protected CatchFrame(AbstractFrame parent, DetailAST ident) {
<span class="fc" id="L668">            super(parent, ident);</span>
<span class="fc" id="L669">        }</span>

        @Override
        public FrameType getType() {
<span class="fc" id="L673">            return FrameType.CATCH_FRAME;</span>
        }

    }

    /**
     * A frame initiated on entering a for block; holds local for variable names.
     */
    protected static class ForFrame extends AbstractFrame {

        /**
         * Creates for frame.
         *
         * @param parent parent frame.
         * @param ident  ident frame name ident.
         */
        protected ForFrame(AbstractFrame parent, DetailAST ident) {
<span class="fc" id="L690">            super(parent, ident);</span>
<span class="fc" id="L691">        }</span>

        @Override
        public FrameType getType() {
<span class="fc" id="L695">            return FrameType.FOR_FRAME;</span>
        }

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>